import{_ as e,o as a,c as s,f as n}from"./app.83926d83.js";const u=JSON.parse('{"title":"给萌新的C/C++环境搭建攻略（VSCode和MSYS2）","description":"使用vscode+MSYS2在windows上搭建C/C++环境，新手向","frontmatter":{"date":"2021-08-18T00:00:00.000Z","update":"2023-01-03T00:00:00.000Z","title":"给萌新的C/C++环境搭建攻略（VSCode和MSYS2）","tags":["vscode","MSYS2","C/C++","配置"],"description":"使用vscode+MSYS2在windows上搭建C/C++环境，新手向"},"headers":[{"level":2,"title":"0. 前言","slug":"_0-前言","link":"#_0-前言","children":[]},{"level":2,"title":"1. 预备知识","slug":"_1-预备知识","link":"#_1-预备知识","children":[{"level":3,"title":"1.1 源代码和编译","slug":"_1-1-源代码和编译","link":"#_1-1-源代码和编译","children":[]},{"level":3,"title":"1.2 命令行和环境变量","slug":"_1-2-命令行和环境变量","link":"#_1-2-命令行和环境变量","children":[]},{"level":3,"title":"1.3 编辑器和IDE","slug":"_1-3-编辑器和ide","link":"#_1-3-编辑器和ide","children":[]}]},{"level":2,"title":"2. 下载安装编译器","slug":"_2-下载安装编译器","link":"#_2-下载安装编译器","children":[{"level":3,"title":"2.1 MinGW/MinGW-w64","slug":"_2-1-mingw-mingw-w64","link":"#_2-1-mingw-mingw-w64","children":[]},{"level":3,"title":"2.2 MSYS2","slug":"_2-2-msys2","link":"#_2-2-msys2","children":[]},{"level":3,"title":"2.3 安装MSYS2和mingw编译器","slug":"_2-3-安装msys2和mingw编译器","link":"#_2-3-安装msys2和mingw编译器","children":[]},{"level":3,"title":"2.4 在命令行使用gcc（选读）","slug":"_2-4-在命令行使用gcc-选读","link":"#_2-4-在命令行使用gcc-选读","children":[]}]},{"level":2,"title":"3. 安装并配置VSCode","slug":"_3-安装并配置vscode","link":"#_3-安装并配置vscode","children":[{"level":3,"title":"3.1 下载安装VSCode","slug":"_3-1-下载安装vscode","link":"#_3-1-下载安装vscode","children":[]},{"level":3,"title":"3.2 VSCode操作简介","slug":"_3-2-vscode操作简介","link":"#_3-2-vscode操作简介","children":[]},{"level":3,"title":"3.3 安装插件","slug":"_3-3-安装插件","link":"#_3-3-安装插件","children":[]},{"level":3,"title":"3.4 受信任文件夹","slug":"_3-4-受信任文件夹","link":"#_3-4-受信任文件夹","children":[]}]},{"level":2,"title":"4. 运行与调试C/C++代码","slug":"_4-运行与调试c-c-代码","link":"#_4-运行与调试c-c-代码","children":[{"level":3,"title":"4.1 单文件的运行","slug":"_4-1-单文件的运行","link":"#_4-1-单文件的运行","children":[]},{"level":3,"title":"4.2 单文件的调试","slug":"_4-2-单文件的调试","link":"#_4-2-单文件的调试","children":[]}]},{"level":2,"title":"5. 踩坑经验和工具推荐","slug":"_5-踩坑经验和工具推荐","link":"#_5-踩坑经验和工具推荐","children":[{"level":3,"title":"5.1 多文件编译和调试","slug":"_5-1-多文件编译和调试","link":"#_5-1-多文件编译和调试","children":[]},{"level":3,"title":"5.2 第三方库的安装和使用","slug":"_5-2-第三方库的安装和使用","link":"#_5-2-第三方库的安装和使用","children":[]},{"level":3,"title":"5.4 其他事项","slug":"_5-4-其他事项","link":"#_5-4-其他事项","children":[]}]},{"level":2,"title":"6. 推荐的参考书和工具网站","slug":"_6-推荐的参考书和工具网站","link":"#_6-推荐的参考书和工具网站","children":[]},{"level":2,"title":"结语","slug":"结语","link":"#结语","children":[{"level":3,"title":"Change Logs","slug":"change-logs","link":"#change-logs","children":[]}]}],"relativePath":"posts/configure-vscode-msys2.md","lastUpdated":null}'),o={name:"posts/configure-vscode-msys2.md"},l=n(`<p><img src="https://pic1.zhimg.com/v2-4198e7216b1e05c319bd739f3b0d2223_1440w.jpg?source=172ae18b" alt="Miyu老师的光光"></p><h1 id="给萌新的c-c-环境搭建攻略-vscode和msys2" tabindex="-1">给萌新的C/C++环境搭建攻略（VSCode和MSYS2） <a class="header-anchor" href="#给萌新的c-c-环境搭建攻略-vscode和msys2" aria-hidden="true">#</a></h1><h2 id="_0-前言" tabindex="-1">0. 前言 <a class="header-anchor" href="#_0-前言" aria-hidden="true">#</a></h2><p>本文写给刚接触编程、希望了解一些原理的CS<strong>萌新</strong>，会介绍一些基本的概念并且推荐一些方便的工具。</p><blockquote><ul><li>像这句话一样写于引用块中的内容一般为补充内容，第一次阅读时可以略过。</li><li>由于是面向新手的文章，所以会比较啰嗦</li><li>不定期更新</li></ul></blockquote><p>本文首发于知乎：<a href="https://zhuanlan.zhihu.com/p/401188789" target="_blank" rel="noreferrer">👉链接👈</a></p><h2 id="_1-预备知识" tabindex="-1">1. 预备知识 <a class="header-anchor" href="#_1-预备知识" aria-hidden="true">#</a></h2><ul><li>请善用<strong>搜索引擎</strong>搜索不太明白的新名词是什么意思，面向<a href="https://stackoverflow.com/" target="_blank" rel="noreferrer">StackOverflow</a>/Google/Baidu编程是不可避免的一环。</li></ul><p>由于<strong>VSCode本质上是个高级记事本</strong>，因此配置它需要一些前置知识。</p><h3 id="_1-1-源代码和编译" tabindex="-1">1.1 源代码和编译 <a class="header-anchor" href="#_1-1-源代码和编译" aria-hidden="true">#</a></h3><p><strong>源代码文件</strong>是存放代码的<strong>文本文件</strong>，C代码文件的后缀名一般为<code>.c</code>，C++代码文件的后缀名一般为<code>.cpp</code>，头文件的后缀名一般为<code>.h</code>，它们都是文本文件（所以可以用记事本打开编辑）。</p><p>文本文件是不能运行的，所以我们需要把写好的代码翻译成机器能够执行的形式，这个过程就被称为<strong>编译</strong>。用来编译代码生成可执行文件的程序被称为<strong>编译器</strong>，目前主流的C/C++编译器有MSVC(<code>cl.exe</code>)、GCC(<code>gcc/g++</code>)和LLVM(<code>clang/clang++</code>)</p><blockquote><p>准确地说源代码文件要变成可执行文件需要进行<strong>预处理</strong>、<strong>编译</strong>、<strong>汇编</strong>、<strong>链接</strong>等步骤，可以参阅<a href="https://zhuanlan.zhihu.com/p/397319639" target="_blank" rel="noreferrer">这篇文章</a></p></blockquote><h3 id="_1-2-命令行和环境变量" tabindex="-1">1.2 命令行和环境变量 <a class="header-anchor" href="#_1-2-命令行和环境变量" aria-hidden="true">#</a></h3><p>命令行界面就是科幻电影中常见的那种全是字符的界面，我们通过输入一些命令来执行操作。</p><p>windows上自带的cmd和powershell就是命令行界面，可以按Win+R输入<code>cmd</code>或<code>powershell</code>来启动它们。启动后会有一串字符提示你现在在哪个路径下，我们可以通过<code>cd</code>命令来切换当前所在的路径。</p><blockquote><p>小技巧：在文件管理器按F4会跳到路径栏，输入cmd并回车即可在此文件夹打开cmd（不用再<code>cd</code>了）。</p><ul><li>不知为何windows自带的powershell不能这么打开</li><li>win11的用户可以直接右键在当前路径打开Windows Terminal</li></ul></blockquote><h4 id="_1-2-1-在命令行界面运行程序" tabindex="-1">1.2.1 在命令行界面运行程序 <a class="header-anchor" href="#_1-2-1-在命令行界面运行程序" aria-hidden="true">#</a></h4><p>只要输入一个程序的相对路径或者绝对路径，就能够运行那个程序（可以不用写<code>.exe</code>）</p><p>以powershell启动steam为例：</p><div class="language-powershell"><button title="Copy Code" class="copy"></button><span class="lang">powershell</span><pre class="shiki dark-plus vp-code-dark"><code><span class="line"><span style="color:#6A9955;"># powershell启动steam</span></span>
<span class="line"><span style="color:#D4D4D4;">cd E:\\steam_main </span><span style="color:#6A9955;"># 首先cd到steam.exe所在的文件夹</span></span>
<span class="line"><span style="color:#D4D4D4;">.\\steam</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;"># 或者直接使用绝对路径</span></span>
<span class="line"><span style="color:#D4D4D4;">E:\\steam_main\\steam</span></span>
<span class="line"></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#008000;"># powershell启动steam</span></span>
<span class="line"><span style="color:#000000;">cd E:\\steam_main </span><span style="color:#008000;"># 首先cd到steam.exe所在的文件夹</span></span>
<span class="line"><span style="color:#000000;">.\\steam</span></span>
<span class="line"></span>
<span class="line"><span style="color:#008000;"># 或者直接使用绝对路径</span></span>
<span class="line"><span style="color:#000000;">E:\\steam_main\\steam</span></span>
<span class="line"></span></code></pre></div><blockquote><p>powershell需要<code>./&lt;名字&gt;</code>或者<code>.\\&lt;名字&gt;</code>来运行当前路径下的程序，但cmd应直接输入<code>&lt;名字&gt;</code></p></blockquote><h4 id="_1-2-2-path变量" tabindex="-1">1.2.2 path变量 <a class="header-anchor" href="#_1-2-2-path变量" aria-hidden="true">#</a></h4><p>每次都需要输入程序的路径当然相当麻烦，有没有办法简化一点？</p><p>答案就是利用<strong>path变量</strong>。</p><p>path变量顾名思义，其中存放了一系列的路径。当你在命令行输入的程序不在当前目录下时，系统就会<strong>依次</strong>去这些路径里找有没有名字一样的程序。所以只要我们把程序的路径加入到path变量，就可以在任意路径下运行它啦。</p><p>例如：将<code>E:\\steam_main</code>添加到path变量中后，就可以在任意路径下输入<code>steam</code>来启动steam</p><h4 id="_1-2-3-修改path变量" tabindex="-1">1.2.3 修改path变量 <a class="header-anchor" href="#_1-2-3-修改path变量" aria-hidden="true">#</a></h4><p>Win+S搜索path，选择<strong>修改系统环境变量</strong>，点开<strong>环境变量</strong>，然后在用户变量（只对当前用户起效）或者系统变量（对所有用户起效）中找到path变量，双击修改即可。</p><blockquote><ul><li>Windows的环境变量有2047字符的最大长度限制，所以不要随便什么东西都往path变量塞</li><li>顺便一提，windows单个路径的长度也有260字符的限制（不要问我是怎么发现这一条和上一条的</li></ul></blockquote><h3 id="_1-3-编辑器和ide" tabindex="-1">1.3 编辑器和IDE <a class="header-anchor" href="#_1-3-编辑器和ide" aria-hidden="true">#</a></h3><p><strong>编辑器</strong>指的是用来编辑源代码文件（文本文件）的程序，windows自带的记事本就是一种编辑器。编辑器可以提供代码高亮、补全等功能，<strong>但本身并不负责把代码编译成可执行文件</strong>，所以需要和编译器搭配使用。</p><p><strong>集成开发环境</strong>（<strong>IDE</strong>），是把编辑器、编译器和其它组件整合到一起的一整套程序。可以直接用它编写代码、编译、调试程序等等，但一般需要你先建一个工程。例如<a href="https://devcpp.gitee.io/" target="_blank" rel="noreferrer">Dev-C++</a>就是经典的C++ IDE.</p><p><strong>VSCode是一种编辑器</strong>，因此需要我们另外下载编译器来编译代码，并且通过一些设置使VSCode能方便地调用编译器并运行编译出来的程序。</p><p>所以我们需要做的就是：</p><ul><li>下载安装C/C++编译器</li><li>下载安装VSCode</li><li>设置VSCode</li></ul><h2 id="_2-下载安装编译器" tabindex="-1">2. 下载安装编译器 <a class="header-anchor" href="#_2-下载安装编译器" aria-hidden="true">#</a></h2><p>首先要下载一个编译器用来编译我们的代码。</p><p>本文使用GCC作为编译器，在windows系统上，推荐通过<strong>MSYS2</strong>来安装它。</p><h3 id="_2-1-mingw-mingw-w64" tabindex="-1">2.1 MinGW/MinGW-w64 <a class="header-anchor" href="#_2-1-mingw-mingw-w64" aria-hidden="true">#</a></h3><p>如果自己搜索过如何在windows上安装gcc的话，一定听说过<strong>MinGW</strong>。GCC本身是Linux上的编译器套件，不能在windows上运行，而mingw则是gcc在windows上的移植。</p><p>最早的mingw项目只支持编译32位程序，后来分支出的mingw-w64项目则同时支持编译32/64位程序。</p><p>网上其它教程的mingw一般都来源于<a href="https://osdn.net/projects/mingw/" target="_blank" rel="noreferrer">MinGW原项目</a>（gcc版本<code>9.2.0-2</code>，只能编译32位程序），或者<a href="https://sourceforge.net/projects/mingw-w64/files/" target="_blank" rel="noreferrer">MinGW-w64的SourceForge</a>（以前可执行文件会放在这上面，但是现在只更新源代码，所以gcc版本停留在<code>8.1.0</code>），版本都相对比较古旧，<strong>不推荐到这两处地方下载mingw</strong>。</p><p>mingw-w64项目目前的状况比较复杂，有多个发行分支，具体可以参看<a href="https://www.mingw-w64.org/downloads/" target="_blank" rel="noreferrer">官网的下载页</a>。目前windows上最新、最靠谱的发行分支就是<strong>MSYS2</strong>（gcc版本<code>12.2.0-6</code>）。</p><blockquote><p>关于mingw和mingw-w64的渊源，可以看<a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/mingw-vs-mingw-v64.md#:~:text=MinGW%20%E5%92%8C%20MinGW%2DW64%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" target="_blank" rel="noreferrer">这篇科普</a></p></blockquote><h3 id="_2-2-msys2" tabindex="-1">2.2 MSYS2 <a class="header-anchor" href="#_2-2-msys2" aria-hidden="true">#</a></h3><p><strong>MSYS2</strong>(Minimal SYStem 2)是与mingw-w64配套的<strong>命令行环境</strong>，它为windows提供了类似linux的命令和<strong>包管理器</strong><code>pacman</code>，可以直接在命令行查找、安装和卸载各种第三方库和开发工具。</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki dark-plus vp-code-dark"><code><span class="line"><span style="color:#6A9955;"># 比如你想要安装opencv库</span></span>
<span class="line"><span style="color:#D4D4D4;">pacman </span><span style="color:#CE9178;">-Syy</span><span style="color:#D4D4D4;"> </span><span style="color:#CE9178;">mingw-w64-ucrt-x86_64-opencv</span></span>
<span class="line"></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#008000;"># 比如你想要安装opencv库</span></span>
<span class="line"><span style="color:#000000;">pacman </span><span style="color:#A31515;">-Syy</span><span style="color:#000000;"> </span><span style="color:#A31515;">mingw-w64-ucrt-x86_64-opencv</span></span>
<span class="line"></span></code></pre></div><blockquote><ul><li><code>pacman</code>同时是ArchLinux的包管理器（就像MacOS上的<code>homebrew</code>和Ubuntu上的<code>apt</code>一样），具体使用办法可以查阅<a href="https://wiki.archlinux.org/title/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noreferrer">ArchWiki(中文)</a></li><li>实际上MinGW也有一个配套的<strong>MSYS</strong>，但它没有包管理器</li><li>git bash实际上是一个<strong>删减版的MSYS2</strong>，在安装文件夹下可以看到MSYS2的目录结构，但它也没有包管理</li></ul></blockquote><h3 id="_2-3-安装msys2和mingw编译器" tabindex="-1">2.3 安装MSYS2和mingw编译器 <a class="header-anchor" href="#_2-3-安装msys2和mingw编译器" aria-hidden="true">#</a></h3><h4 id="_2-3-1-下载安装msys2" tabindex="-1">2.3.1 下载安装MSYS2 <a class="header-anchor" href="#_2-3-1-下载安装msys2" aria-hidden="true">#</a></h4><p>安装MSYS2很简单，前往<a href="https://www.msys2.org/" target="_blank" rel="noreferrer">MSYS2官网</a>下载安装程序即可。安装过程就是选安装位置，然后一直点下一步，没有什么需要特别注意的地方。</p><p><img src="https://pic4.zhimg.com/80/v2-77b7be8e2d0cd35e10aee95ac2713e35.png" alt="点击图中所示位置下载MSYS2"></p><blockquote><p>可能在这一步会遇到网络问题，访问不了官网或者下不了安装包。可以考虑去清华镜像站或者科大镜像站下载：</p><ul><li>清华镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/msys2/distrib/x86_64" target="_blank" rel="noreferrer">https://mirrors.tuna.tsinghua.edu.cn/msys2/distrib/x86_64</a></li><li>科大镜像：<a href="https://mirrors.ustc.edu.cn/msys2/distrib/" target="_blank" rel="noreferrer">https://mirrors.ustc.edu.cn/msys2/distrib/</a></li></ul><p>注意windows安装包的名字类似于<code>msys2-x86_64-20221028.exe</code>，不要下载<code>*.tar.xz</code>的，那是Linux的压缩包</p></blockquote><h4 id="_2-3-2-msys2的子环境-选读" tabindex="-1">2.3.2 MSYS2的子环境（选读） <a class="header-anchor" href="#_2-3-2-msys2的子环境-选读" aria-hidden="true">#</a></h4><p>MSYS2实际上是由6个独立的子环境组成的。每个子环境会有一个单独的文件夹，和一个专门的命令行界面入口，具体区别见下图。一般来说，直接使用<strong>UCRT64</strong>就行。</p><p><img src="https://pic4.zhimg.com/80/v2-f00bbacc77a4113fbae255ff19c69941.png" alt="MSYS2包含的几个子环境"></p><p>打开MSYS2的安装目录，可以看到这些子环境的位置。刚安装好MSYS2的话，除了usr文件夹以外，其它的子环境文件夹里应该还都是空的。</p><p><img src="https://pic4.zhimg.com/80/v2-4f87bed7af53a014a1c626003b34d078.png" alt="MSYS2的安装目录结构"></p><p>一般来说，每个子环境下都有<code>bin</code>（含编译器的可执行文件等）/<code>include</code>（标准库和安装的第三方库头文件）/<code>lib</code>（动态库和静态库等）等文件夹，如果遇到问题可以去相应的路径查看。</p><blockquote><p>详细解释一下几个子环境的区别：</p><ul><li>MSYS环境是基础环境，包含各种linux命令行工具（例如<code>pacman</code>等），其它子环境都继承于它。但在这个子环境里编译的程序<strong>依赖于MSYS2的动态库</strong>，因此直接把编译出来的<code>.exe</code>发给其他人的话会无法运行，需要带上<code>/usr/bin</code>文件夹下的<code>MSYS-2.0.dll</code>等依赖库才行。<strong>一般不建议使用</strong>。（需要完整linux环境的请考虑<strong>WSL</strong>或者虚拟机）</li><li>MINGW64环境编译的程序不依赖MSYS2，只依赖于windows自带的C语言库<code>msvcrt</code>，较为通用。</li><li>UCRT64与MINGW64类似，但依赖于比较新的C语言库<code>ucrt</code>，这个库win10/11自带，也是目前微软家的<a href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noreferrer">Visual Studio</a>使用的库，但win7/XP可能需要手动安装。未来将会替代MINGW64。</li><li>CLANG64环境使用LLVM工具链而非GCC工具链，所有配套环境都是基于LLVM的（比如这个环境里的<code>gcc.exe</code>其实是<code>clang.exe</code>的重命名）。</li><li>MINGW32和CLANG32顾名思义，使用32位的mingw/clang工具链，如果没有特殊需求基本不用考虑，用64位版本就好。</li></ul><p>最早只有MSYS，MINGW64和MINGW32三个子环境，子环境数量由于开发的需要正在增加，将来可能还会加入CLANGARM64(可用于Android程序编译)</p></blockquote><h4 id="_2-3-3-使用pacman安装编译器" tabindex="-1">2.3.3 使用pacman安装编译器 <a class="header-anchor" href="#_2-3-3-使用pacman安装编译器" aria-hidden="true">#</a></h4><p>打开MSYS2命令行，输入<code>pacman -Syu</code>同步更新所有工具，然后输入<code>pacman -S mingw-w64-ucrt-x86_64-toolchain</code>安装mingw-w64工具链。中间出现询问之类的一路回车就好，等待一段时间后应该就安装完毕了。</p><p><img src="https://pic4.zhimg.com/80/v2-9a85c3eb240ae56afabf39b9bfc923c0.png" alt="安装mingw工具链"></p><p>安装完成后ucrt64/bin文件夹下应该能找到<code>gcc.exe</code>，然后将此路径<strong>加入环境变量</strong>。</p><p>如果一切正常，那么打开命令行，输入<code>gcc --version</code>应当能显示<code>gcc</code>的版本，MSYS2目前的gcc版本是<code>12.1.0 Rev2</code>。</p><p>如果提示找不到gcc或者gcc不是批处理等错误，可以尝试关闭重开powershell/cmd再次尝试，如果仍然失败，那么应当是环境变量没有设置对。</p><p><img src="https://pic4.zhimg.com/80/v2-dc2092e5086fb4fb6e3b2fe51158953c.png" alt="检查gcc版本"></p><p>如果没有问题，那么我们的编译器就<strong>安装成功</strong>啦。</p><h3 id="_2-4-在命令行使用gcc-选读" tabindex="-1">2.4 在命令行使用gcc（选读） <a class="header-anchor" href="#_2-4-在命令行使用gcc-选读" aria-hidden="true">#</a></h3><p>事实上，我们现在已经可以写C/C++代码并运行了。例如，新建一个文本文件<code>hello.c</code>，内容如下</p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki dark-plus vp-code-dark"><code><span class="line"><span style="color:#C586C0;">#include</span><span style="color:#569CD6;"> </span><span style="color:#CE9178;">&lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6;">int</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">main</span><span style="color:#D4D4D4;">(</span><span style="color:#569CD6;">void</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#DCDCAA;">puts</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&quot;Hello, world!&quot;</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#C586C0;">return</span><span style="color:#D4D4D4;"> </span><span style="color:#B5CEA8;">0</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#AF00DB;">#include</span><span style="color:#0000FF;"> </span><span style="color:#A31515;">&lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#0000FF;">int</span><span style="color:#000000;"> </span><span style="color:#795E26;">main</span><span style="color:#000000;">(</span><span style="color:#0000FF;">void</span><span style="color:#000000;">) {</span></span>
<span class="line"><span style="color:#000000;">    </span><span style="color:#795E26;">puts</span><span style="color:#000000;">(</span><span style="color:#A31515;">&quot;Hello, world!&quot;</span><span style="color:#000000;">);</span></span>
<span class="line"><span style="color:#000000;">    </span><span style="color:#AF00DB;">return</span><span style="color:#000000;"> </span><span style="color:#098658;">0</span><span style="color:#000000;">;</span></span>
<span class="line"><span style="color:#000000;">}</span></span>
<span class="line"></span></code></pre></div><p>然后在这个路径下命令行输入<code>gcc hello.c -o hello</code>，就能生成一个<code>hello.exe</code>文件，在命令行运行它就能看到输出。（不要双击运行它，因为运行结束后默认会退出命令行界面，你就看不到输出了！）</p><p><img src="https://pic4.zhimg.com/80/v2-caa200da383ad6352a22643115ab2eaf.png" alt="命令行编译运行"></p><p>简单来说，输入<code>gcc &lt;源代码文件&gt; -o &lt;输出程序名字&gt;</code>就可以将C代码文件编译成指定名字的可执行文件。而对于C++代码，将gcc换成g++就行。</p><p>如果你能接受使用<strong>Notepad2</strong>之类的轻量化编辑器加上手打命令行编译运行的话，也够应付刚入门时的各种单文件小程序了（不过缺点是不能调试）。</p><p>而在VSCode（和各种IDE）中，本质上就是将这里这个手动输入命令行的过程自动化了。</p><blockquote><p>详细的gcc使用说明可以参考<a href="https://www.runoob.com/w3cnote/gcc-parameter-detail.html" target="_blank" rel="noreferrer">这个</a>，不过如果英文可以的话建议还是看<a href="https://gcc.gnu.org/onlinedocs/gcc-10.3.0/gcc/Option-Summary.html#Option-Summary" target="_blank" rel="noreferrer">GNU手册</a></p></blockquote><h2 id="_3-安装并配置vscode" tabindex="-1">3. 安装并配置VSCode <a class="header-anchor" href="#_3-安装并配置vscode" aria-hidden="true">#</a></h2><h3 id="_3-1-下载安装vscode" tabindex="-1">3.1 下载安装VSCode <a class="header-anchor" href="#_3-1-下载安装vscode" aria-hidden="true">#</a></h3><p>去<a href="https://code.visualstudio.com/" target="_blank" rel="noreferrer">VSCode官网</a>下载安装包，按照提示安装就行。</p><p>建议勾选在右键菜单中添加“通过code打开”，方便我们在指定位置打开vscode。</p><p><img src="https://pic4.zhimg.com/80/v2-a0742a5f74ae6d764145fa0285aa1713.png" alt="勾选“通过code打开”这两项"></p><h3 id="_3-2-vscode操作简介" tabindex="-1">3.2 VSCode操作简介 <a class="header-anchor" href="#_3-2-vscode操作简介" aria-hidden="true">#</a></h3><p>简单介绍一下常用的VSCode操作。</p><h4 id="_3-2-1-内置命令行" tabindex="-1">3.2.1 内置命令行 <a class="header-anchor" href="#_3-2-1-内置命令行" aria-hidden="true">#</a></h4><p>VSCode内置了命令行，按下快捷键<code>Ctrl+\`</code>，就可以调出内置的集成终端以便使用。VSCode默认使用powershell作为终端。</p><h4 id="_3-2-2-常用快捷键" tabindex="-1">3.2.2 常用快捷键 <a class="header-anchor" href="#_3-2-2-常用快捷键" aria-hidden="true">#</a></h4><ul><li><code>F1/Ctrl+Shift+P</code>：查找运行vscode命令</li><li><code>Ctrl+,</code>：打开vscode设置</li><li><code>Ctrl+Shift+K</code>：删除整行</li><li><code>Alt+上下方向键</code>：移动行</li><li><code>Shift+Alt+F</code>：代码格式化</li><li>按住<code>Alt</code>用鼠标点选可以选中多处</li><li>按住<code>Shift+Alt</code>可以鼠标拖动多选</li><li><code>Ctrl+D</code>选中一个单词，<code>Ctrl+L</code>选中一整行</li></ul><h3 id="_3-3-安装插件" tabindex="-1">3.3 安装插件 <a class="header-anchor" href="#_3-3-安装插件" aria-hidden="true">#</a></h3><p>初次进入vscode的话，会是全英文界面，需要安装中文插件来切换到中文，一般来说现在会在右下角弹出来，点击安装就行。</p><p>然后打开插件栏，搜索安装C/C++和Code Runner插件，用来提供C/C++代码高亮和编译运行C/C++代码。</p><p><img src="https://pic4.zhimg.com/80/v2-14af64c1944cc6be2dee8252acb2c841.png" alt="安装插件"></p><p>打开设置，<strong>勾选code runner插件设置中的run in terminal选项</strong>，让代码在vscode的集成终端里运行，这样才能在命令行输入。</p><h3 id="_3-4-受信任文件夹" tabindex="-1">3.4 受信任文件夹 <a class="header-anchor" href="#_3-4-受信任文件夹" aria-hidden="true">#</a></h3><p>vscode最近的更新增加了一个信任工作区，每打开一个新的文件夹都会提示你是否信任，这个功能挺麻烦的，可以关掉。</p><p>使用<code>Ctrl+,</code>打开设置，搜索“信任”，取消勾选“启用工作区信任”，即可关掉这个功能。</p><h2 id="_4-运行与调试c-c-代码" tabindex="-1">4. 运行与调试C/C++代码 <a class="header-anchor" href="#_4-运行与调试c-c-代码" aria-hidden="true">#</a></h2><h3 id="_4-1-单文件的运行" tabindex="-1">4.1 单文件的运行 <a class="header-anchor" href="#_4-1-单文件的运行" aria-hidden="true">#</a></h3><p>对于单个源文件的C/C++代码来说，可以直接使用code runner来运行。只要点击右上角的小三角形，或者使用快捷键<code>Ctrl+Alt+N</code>就能编译运行C语言代码。</p><blockquote><p>其实可以看到，code runner的原理就是自动在命令行输入编译和运行的命令，和我们自己手动输入命令没有区别。</p><p>输入的命令也可以在相应的插件设置中进行修改。</p></blockquote><p><img src="https://pic4.zhimg.com/80/v2-f89550f28288cb353b79812f3555c2e0.png" alt="使用code runner运行C代码"></p><h3 id="_4-2-单文件的调试" tabindex="-1">4.2 单文件的调试 <a class="header-anchor" href="#_4-2-单文件的调试" aria-hidden="true">#</a></h3><p>按下F5，依次选择C++(GDB/LLDB)和我们MSYS2环境中的gcc.exe，VSCode会自动生成配置文件，并生成调试。</p><p><img src="https://pic4.zhimg.com/80/v2-ebe3544a15810cb74c3af23768fe25d3.png" alt=""></p><p><img src="https://pic4.zhimg.com/80/v2-186ac960eca266c963ac00304cedce39.png" alt=""></p><p>可以在行号的左边单击来设置断点，程序运行到断点前会自行中断。左侧可以看到此时各个变量的值，监视栏中可以输入表达式观察。</p><p><img src="https://pic4.zhimg.com/80/v2-b085d9f9266995f4e6ad0f3c609d0d0f.png" alt="VSCode调试界面"></p><p>另外，目前VSCode支持了<strong>条件断点</strong>，只要右键断点，选择编辑断点即可设置中断条件，具体使用方法可以参考<a href="https://code.visualstudio.com/docs/cpp/cpp-debug" target="_blank" rel="noreferrer">VSCode文档</a>。</p><p><img src="https://pic4.zhimg.com/80/v2-b31b3cc18ef93a4cec50ff3ee0004157.png" alt="VSCode的条件断点"></p><p><strong>至此，可以愉快地写代码啦。</strong></p><hr><p>下面的内容是一些工具推荐和踩坑经验，留给有<strong>一定基础</strong>的C/C++<strong>初学者</strong>。</p><h2 id="_5-踩坑经验和工具推荐" tabindex="-1">5. 踩坑经验和工具推荐 <a class="header-anchor" href="#_5-踩坑经验和工具推荐" aria-hidden="true">#</a></h2><h3 id="_5-1-多文件编译和调试" tabindex="-1">5.1 多文件编译和调试 <a class="header-anchor" href="#_5-1-多文件编译和调试" aria-hidden="true">#</a></h3><p>读者可能会注意到上一节中我们只提了<strong>单文件</strong>的运行和调试，没有提到多文件的运行及调试。</p><p>这是由于用VSCode多文件编译，不可避免地需要涉及<strong>C/C++编译系统</strong>的概念，不太适合刚入门的初学者学习，这里给出几种方案和一些参考链接。</p><p>简单来说，编译系统要解决的基本问题有两个：一个是<strong>哪些文件需要以何种方式被编译到一起</strong>，另一个是<strong>当某个文件被修改的时候，哪些文件需要被重新编译</strong>。这一般需要我们编写配置文件（Makefile, CMakeLists.txt等）来描述各个代码文件间的关系，然后相应的程序可以根据配置文件调用编译器完成编译。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/29910215" target="_blank" rel="noreferrer">这篇文章</a>以make/automake为例，讲解了编译系统是如何从脚本开始演化为现在的样子的。写的很好，只是作者已经不在知乎了。</p></blockquote><h4 id="_5-1-1-make" tabindex="-1">5.1.1 Make <a class="header-anchor" href="#_5-1-1-make" aria-hidden="true">#</a></h4><p>Make是最原始的C/C++编译系统，语法简单，是linux原生的多文件编译方案。需要注意的是mingw项目中的make叫做<code>mingw32-make</code>，需要复制一份<strong>重命名</strong>为<code>make</code>.</p><blockquote><p>详细的make指南可以查阅<a href="https://seisman.github.io/how-to-write-makefile" target="_blank" rel="noreferrer">这里</a>。</p></blockquote><p>我最初多文件运行/调试使用的就是make，可以调整code runner的命令行来使用make进行编译，调试的话则要自己调整<code>task.json</code>文件。</p><p>不建议初学者自己在VSCode上配置makefile工程，比较麻烦。我写了一个<a href="https://github.com/Locietta/vscode-makefile-template" target="_blank" rel="noreferrer">VSCode的makefile工程模板</a>放到了Github上，感兴趣的可以查看和使用（有问题也可以直接提交issue）。</p><h4 id="_5-1-2-cmake-ninja" tabindex="-1">5.1.2 CMake+Ninja <a class="header-anchor" href="#_5-1-2-cmake-ninja" aria-hidden="true">#</a></h4><p>当然make已经是相当古老的工具了，如今最为广泛使用的C/C++编译系统是<a href="https://cmake.org/" target="_blank" rel="noreferrer">CMake</a>。CMake的优点是可以生成其它工具和IDE的配置文件，便于我们编写跨平台、跨IDE的C/C++工程。</p><p>VSCode对CMake的集成很不错，有微软官方的<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools" target="_blank" rel="noreferrer">cmake-tools插件</a>支持，可以不编写<code>launch.json</code>和<code>task.json</code>直接根据cmake当前的配置进行运行和调试。如果检测到路径中有<a href="https://ninja-build.org/" target="_blank" rel="noreferrer">ninja</a>，则会自动调用ninja加速编译。</p><p>在MSYS2中使用<code>pacman -S mingw-w64-ucrt-x86_64-cmake mingw-w64-ucrt-x86_64-ninja</code>即可在UCRT64环境中安装cmake+ninja.</p><p>如果想学习CMake，那么可以看<a href="https://www.bookstack.cn/read/CMake-Cookbook/README.md" target="_blank" rel="noreferrer">CMake Cook Book</a>和<a href="https://github.com/xiaoweiChen/Modern-CMake-for-Cpp/releases" target="_blank" rel="noreferrer">Modern CMake for Cpp</a>这两本书。（都是中文版，由同一位大佬翻译）。</p><blockquote><p><a href="https://www.zhihu.com/question/276415476#:~:text=%E7%AC%AC%E4%BA%8C%EF%BC%8CCMake%E6%B2%A1%E6%9C%89,%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%82" target="_blank" rel="noreferrer">CMake的官方文档是出了名的烂</a>，强烈不建议直接硬啃文档来学CMake. 仅推荐必要时查阅。</p></blockquote><h4 id="_5-1-3-xmake" tabindex="-1">5.1.3 xmake <a class="header-anchor" href="#_5-1-3-xmake" aria-hidden="true">#</a></h4><p>总之如果你使用了一段时间cmake，你就会发现cmake用起来总是有各种各样让人不舒服的地方，由国人开发的<a href="https://xmake.io/#/zh-cn/" target="_blank" rel="noreferrer">xmake</a>可能是它的一个更好的替代。</p><p>xmake相比cmake更快，集成度更高（集成了<strong>包管理</strong>和分布式编译等），给我的感觉就像C/C++版本的<code>cargo</code>(rust邪教(不))。而且也支持<a href="https://xmake.io/#/zh-cn/package/local_3rd_source_library" target="_blank" rel="noreferrer">直接集成使用cmake等其他编译系统的C/C++项目</a>，减少迁移成本。</p><p>插件支持方面，vscode上也有xmake的插件支持，能提供和cmake-tools插件类似的功能，总之推荐尝试一下。</p><blockquote><p>唯一的问题就是用的人比较少，而CMake最大的优点就是大家都在用...</p></blockquote><p><strong>一些注意事项：</strong></p><ul><li>使用<code>pacman -S mingw-w64-ucrt-x86_64-xmake</code>可在UCRT64环境中安装xmake。不过这样<code>xrepo</code>只能在UCRT64的shell里用，在外面用需要写个wrapper脚本</li><li>或者也可使用windows上的包管理器<a href="https://scoop.sh/" target="_blank" rel="noreferrer">scoop</a>来安装原生的xmake，命令是<code>scoop install xmake</code>，没有上述问题</li><li>开始使用前需要用<code>xmake g --mingw=$env:MSYS2\\ucrt64</code>设置mingw的路径（如果你用cmd，那么是<code>xmake g --mingw=%MSYS2%\\ucrt64</code>）</li><li>其他设置可以去看<a href="https://xmake.io/#/zh-cn/guide/configuration" target="_blank" rel="noreferrer">xmake官网</a>，并善用浏览器<code>ctrl+f</code>搜索</li></ul><h3 id="_5-2-第三方库的安装和使用" tabindex="-1">5.2 第三方库的安装和使用 <a class="header-anchor" href="#_5-2-第三方库的安装和使用" aria-hidden="true">#</a></h3><p>C/C++最让人头疼的地方之一就是如何安装和使用第三方库了，对新手来说编译一个第三方库的项目基本上是个噩梦，遇到错误往往摸不着头脑。</p><h4 id="_5-2-1-第三方库的安装" tabindex="-1">5.2.1 第三方库的安装 <a class="header-anchor" href="#_5-2-1-第三方库的安装" aria-hidden="true">#</a></h4><p>本文选用MSYS2，一个主要的考虑就是为了方便安装第三方库。只需要<code>pacman -Ss</code>搜索一下库的名字，再按搜出来的名字<code>pacman -S</code>安装就行了，大部分常用的第三方库都能找到。头文件安装在<code>子环境名/include</code>，库二进制文件则安装在<code>子环境名/lib</code>下，这两个路径是编译器的默认搜索路径。</p><blockquote><ul><li>如果使用过python，那么可以把<code>pacman</code>理解为类似于<code>pip</code>一样的东西。</li><li>需要先<code>pacman -Ss</code>搜索，因为除了MSYS子环境，包名通常会有一个很长的前缀，和库本身的名字并不相同。例如<code>pacman -S cmake</code>安装的是MSYS子环境的cmake，要安装ming64子环境下的cmake，则应该是<code>pacman -S mingw-w64-x86_64-cmake</code></li></ul></blockquote><h4 id="_5-2-2-第三方库的使用" tabindex="-1">5.2.2 第三方库的使用 <a class="header-anchor" href="#_5-2-2-第三方库的使用" aria-hidden="true">#</a></h4><p><strong>头文件include错误</strong></p><p>因为头文件直接装在了默认搜索路径里，所以一般安装完毕后直接<code>#include &lt;...&gt;</code>就可以了。</p><p>但是也有例外，比如OpenCV的头文件是在默认路径的一个子文件夹下，是一个独立的include系统，这时候需要为编译器指定<code>-isystem &lt;路径&gt;</code>选项。</p><p><strong>undefined reference</strong></p><p>这种情况是因为编译器不知道某个库函数的实现在哪。你需要使用gcc的<code>-l</code>选项链接安装的库，比如<code>g++ a.cpp -lfmt</code>就是指定编译<code>a.cpp</code>的时候要链接<code>libfmt.a</code>库文件。如果不知道库文件的名字，可以去<code>lib</code>文件夹下查看。</p><p><strong>命令行好麻烦</strong></p><p>你会觉得手动书写上述命令行好麻烦，对吧？如果你使用cmake或者xmake的话，只需要使用<code>find_package(库)</code>(cmake)或者<code>add_requires(&quot;库&quot;)</code>(xmake)就行了。它们会自动帮你处理上述的两个问题的。</p><blockquote><ul><li>对cmake来说，库的名字应该填<code>/share/cmake/Modules</code>下的<code>Find&lt;库名&gt;.cmake</code>所对应的名字</li><li>对xmake来说，上述cmake的包可以用<code>add_requires(&quot;cmake::&lt;库名&gt;&quot;)</code>来找到，也可以指定其他来源，或者直接从远程下载. 可以用<code>xmake l find_package &lt;库名&gt;</code>来测试是否能够找到想要的库。</li></ul></blockquote><h4 id="_5-3-杀毒软件" tabindex="-1">5.3 杀毒软件 <a class="header-anchor" href="#_5-3-杀毒软件" aria-hidden="true">#</a></h4><p>杀毒软件实时监测磁盘上的文件，会拖慢windows上的编译速度。特别是当项目较大，生成的文件比较多时，影响更为明显。此外，部分杀软还会将我们自己编写的程序识别为病毒。因此最好将常用的编写代码文件夹加入杀软的白名单/排除项。</p><blockquote><p>但不管怎么样，windows上的编译速度一般还是比linux上慢不少</p></blockquote><h3 id="_5-4-其他事项" tabindex="-1">5.4 其他事项 <a class="header-anchor" href="#_5-4-其他事项" aria-hidden="true">#</a></h3><h4 id="_5-4-1-clang-llvm工具链" tabindex="-1">5.4.1 Clang/LLVM工具链 <a class="header-anchor" href="#_5-4-1-clang-llvm工具链" aria-hidden="true">#</a></h4><p>这部分曾经想单独开一篇文章写，现在想想似乎也没有那么多内容，就在这里简要介绍一下吧。</p><ul><li><code>clangd</code>配合vscode上的同名插件，可以提供比vscode官方C++插件更好更快的<strong>语法高亮</strong>支持，不过需要注意生成<code>compile_commands.json</code>。（<strong>强烈推荐</strong>）</li><li><code>lldb</code>配合CodeLLDB插件提供更加强大的<strong>调试</strong>功能（可以调试Rust代码，可以嵌入python脚本来在调试时做内存可视化），不过如果不写rust的话与官方插件差别不大，可酌情安装</li><li><code>clang-format</code>是现在通用的C/C++<strong>格式化</strong>工具，vscode的clangd插件和C++官方插件都支持它，不必额外安装插件</li><li><code>clang-tidy</code>是一个基于AST的<strong>代码规范</strong>工具，可以自动检查出代码中性能不佳或者不合代码规范的问题，对于部分问题还可以提出修复方案。clangd插件对其有部分支持，完整支持需要独立插件，请酌情安装</li></ul><p>安装则只需用<code>pacman</code>把UCRT环境的clang-tools-extra和lldb安装上就行了。如果启用clangd，但仍想使用官方插件的调试功能，可以在设置把官方插件的intellisense engine和autocomplete都给关掉以免冲突。</p><h4 id="_5-4-2-windows-terminal" tabindex="-1">5.4.2 Windows Terminal <a class="header-anchor" href="#_5-4-2-windows-terminal" aria-hidden="true">#</a></h4><p>如果你在电脑上安装了很多环境，就会发现有一大堆各种不同的命令行入口，管理起来十分不便。使用windows terminal可以将各种命令行界面入口整合到一起，界面也更加美观，还能改善部分命令行界面的复制粘贴体验（点名批评MSYS2/git bash这一系列的shell）。</p><p><img src="https://pic4.zhimg.com/80/v2-d531eff13e8f1995d0e6849a70cddfb3.png" alt="使用windows terminal管理各种命令行入口"></p><p>windows terminal可以直接在win10自带的微软商店里免费下载。而在win11则是默认的命令行程序（但是仍然推荐去商店更新一下，因为自带的版本比较古旧，甚至没有图形化的设置界面）。</p><h4 id="_5-4-3-win7-8" tabindex="-1">5.4.3 WIN7/8 <a class="header-anchor" href="#_5-4-3-win7-8" aria-hidden="true">#</a></h4><p>已经是2022年了，由于<a href="https://cygwin.com/pipermail/cygwin-announce/2021-October/010271.html" target="_blank" rel="noreferrer">Cygwin即将移除win7/win8的支持</a>，MSYS2也将紧随其后，<a href="https://github.com/msys2/MSYS2-packages/issues/2696" target="_blank" rel="noreferrer">在2022年底结束对win7/8的支持</a>（但应该仍然支持win8.1）。</p><p>MSYS2官方有计划为win7/8提供<a href="https://github.com/msys2/msys2-archive" target="_blank" rel="noreferrer">msys2-archive镜像</a>，但相关工作似乎还没有开始。如果你还留在win7/win8，那么你可能需要考虑MSYS2的替代品。使用一个更老的工具链，然后使用xmake/conan来管理包依赖或许是一个可行的选择。</p><h4 id="_5-4-4-把-msys2-usr-bin加入path变量" tabindex="-1">5.4.4 把<code>%MSYS2%/usr/bin</code>加入path变量？ <a class="header-anchor" href="#_5-4-4-把-msys2-usr-bin加入path变量" aria-hidden="true">#</a></h4><p><strong>这是个危险操作</strong>，不是很建议这么干，因为很可能遇到很多环境冲突问题。如果你需要在cmd里面执行linux的命令，考虑利用wsl1. 如果需要在MSYS2的shell外面使用子环境的命令，那么可以新建如下<code>msys2.cmd</code>文件放到path变量中的路径下。</p><div class="language-batch"><button title="Copy Code" class="copy"></button><span class="lang">batch</span><pre class="shiki dark-plus vp-code-dark"><code><span class="line"><span style="color:#D4D4D4;">@</span><span style="color:#569CD6;">echo</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">off</span></span>
<span class="line"><span style="color:#C586C0;">if</span><span style="color:#D4D4D4;"> </span><span style="color:#CE9178;">&quot;</span><span style="color:#9CDCFE;">%1</span><span style="color:#CE9178;">&quot;</span><span style="color:#D4D4D4;">==</span><span style="color:#CE9178;">&quot;&quot;</span><span style="color:#D4D4D4;"> </span><span style="color:#C586C0;">goto</span><span style="color:#D4D4D4;"> noarg</span></span>
<span class="line"><span style="color:#9CDCFE;">%MSYS2%</span><span style="color:#D4D4D4;">\\msys2_shell.cmd -defterm -no-start -here -msys2 -c </span><span style="color:#CE9178;">&quot;</span><span style="color:#9CDCFE;">%*</span><span style="color:#CE9178;">&quot;</span></span>
<span class="line"><span style="color:#C586C0;">goto</span><span style="color:#D4D4D4;"> :</span><span style="color:#569CD6;">eof</span></span>
<span class="line"><span style="color:#D4D4D4;">:</span><span style="color:#569CD6;">noarg</span></span>
<span class="line"><span style="color:#9CDCFE;">%MSYS2%</span><span style="color:#D4D4D4;">\\msys2_shell.cmd -defterm -no-start -here -msys2</span></span>
<span class="line"></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#000000;">@</span><span style="color:#0000FF;">echo</span><span style="color:#000000;"> </span><span style="color:#0000FF;">off</span></span>
<span class="line"><span style="color:#AF00DB;">if</span><span style="color:#000000;"> </span><span style="color:#A31515;">&quot;</span><span style="color:#001080;">%1</span><span style="color:#A31515;">&quot;</span><span style="color:#000000;">==</span><span style="color:#A31515;">&quot;&quot;</span><span style="color:#000000;"> </span><span style="color:#AF00DB;">goto</span><span style="color:#000000;"> noarg</span></span>
<span class="line"><span style="color:#001080;">%MSYS2%</span><span style="color:#000000;">\\msys2_shell.cmd -defterm -no-start -here -msys2 -c </span><span style="color:#A31515;">&quot;</span><span style="color:#001080;">%*</span><span style="color:#A31515;">&quot;</span></span>
<span class="line"><span style="color:#AF00DB;">goto</span><span style="color:#000000;"> :</span><span style="color:#0000FF;">eof</span></span>
<span class="line"><span style="color:#000000;">:</span><span style="color:#0000FF;">noarg</span></span>
<span class="line"><span style="color:#001080;">%MSYS2%</span><span style="color:#000000;">\\msys2_shell.cmd -defterm -no-start -here -msys2</span></span>
<span class="line"></span></code></pre></div><p>这样一来，我们就可以在powershell/cmd中直接使用<code>msys2 &lt;command&gt;</code>来在MSYS子环境中运行命令，例如运行<code>msys2 pacman -Syyu</code>直接更新msys2.</p><p>如果不给参数直接输入<code>msys2</code>则会进入MSYS环境，输入<code>exit</code>可以退回到原来的shell.</p><blockquote><ul><li>UCRT64/MINGW64环境的wrapper脚本也类似，见<a href="https://github.com/Locietta/useful-script/blob/master/wrappers" target="_blank" rel="noreferrer">我的github仓库</a></li></ul><p>如有可能，也请尽量避免将MINGW64/UCRT64的bin路径加入path。使用专用的shell或者使用wrapper可以避免污染系统环境。</p></blockquote><h4 id="_5-4-5-在pacman-ss中屏蔽掉不想要的子环境" tabindex="-1">5.4.5 在<code>pacman -Ss</code>中屏蔽掉不想要的子环境 <a class="header-anchor" href="#_5-4-5-在pacman-ss中屏蔽掉不想要的子环境" aria-hidden="true">#</a></h4><p>打开<code>%MSYS2%/etc/pacman.conf</code>，到最下面用<code>#</code>注释掉不想要的子环境源。</p><div class="language-ini"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki dark-plus vp-code-dark"><code><span class="line"><span style="color:#6A9955;"># 如果不想在pacman -Ss里看到mingw32环境的包</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;">#[mingw32]</span></span>
<span class="line"><span style="color:#6A9955;">#Include = /etc/pacman.d/mirrorlist.mingw</span></span>
<span class="line"></span></code></pre><pre class="shiki light-plus vp-code-light"><code><span class="line"><span style="color:#008000;"># 如果不想在pacman -Ss里看到mingw32环境的包</span></span>
<span class="line"></span>
<span class="line"><span style="color:#008000;">#[mingw32]</span></span>
<span class="line"><span style="color:#008000;">#Include = /etc/pacman.d/mirrorlist.mingw</span></span>
<span class="line"></span></code></pre></div><h4 id="_5-4-6-让pacman优先使用国内镜像" tabindex="-1">5.4.6 让pacman优先使用国内镜像 <a class="header-anchor" href="#_5-4-6-让pacman优先使用国内镜像" aria-hidden="true">#</a></h4><p><code>pacman</code>默认优先使用MSYS2官方源，在国内的速度可能比较慢，可以考虑修改配置让它优先使用国内的镜像（比如科大或者清华的）。</p><p>去<code>%MSYS2%\\etc\\pacman.d</code>路径下，找到<code>mirrorlist.&lt;子环境&gt;</code>文件，然后把其中USTC或者TUNA的链接移到最上方即可。</p><p>例如，将<code>Server = https://mirrors.ustc.edu.cn/msys2/mingw/ucrt64/</code>移到<code>mirrorlist.ucrt64</code>的最上方，即可让UCRT64子环境的包优先使用科大镜像下载。</p><h2 id="_6-推荐的参考书和工具网站" tabindex="-1">6. 推荐的参考书和工具网站 <a class="header-anchor" href="#_6-推荐的参考书和工具网站" aria-hidden="true">#</a></h2><h4 id="_6-1-入门c-c-的用书推荐" tabindex="-1">6.1 入门C/C++的用书推荐 <a class="header-anchor" href="#_6-1-入门c-c-的用书推荐" aria-hidden="true">#</a></h4><ul><li>C Primer Plus （C语言的内容）</li><li>C++ Primer Plus （C++11及以前的内容）</li><li><a href="https://changkun.de/modern-cpp/" target="_blank" rel="noreferrer">高速上手现代C++</a> （现代C++(C++11/14/17/20)的新发展，建议配合上一本食用。本书仍在写作中，作者是国人大佬，目前<a href="https://github.com/changkun/modern-cpp-tutorial" target="_blank" rel="noreferrer">开源在Github上</a>）</li></ul><blockquote><p>如果能魔法上网，那么也可以关注油管上<a href="https://www.youtube.com/user/CppCon/videos" target="_blank" rel="noreferrer">Cpp Conference的频道</a>，通过Cpp会议大牛的演讲来了解C++.</p></blockquote><h4 id="_6-2-常用的工具网站" tabindex="-1">6.2 常用的工具网站 <a class="header-anchor" href="#_6-2-常用的工具网站" aria-hidden="true">#</a></h4><ul><li>C/C++的各种标准库函数怎么用可以查阅<a href="https://en.cppreference.com/w/Main_Page" target="_blank" rel="noreferrer">cppreference</a>或者<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5" target="_blank" rel="noreferrer">cppreference(中文)</a>。这个网站的内容基于C和C++最新的标准草案内容编写，关于标准库的内容最新，也最齐全。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-66e3893a58dd00da0175038d3910000c.png" alt="cppreference"></p><ul><li>在线编译器网站：<a href="https://godbolt.org/" target="_blank" rel="noreferrer">compiler explorer</a>. 可以在线编译C/C++的函数，观察不同的编译器，不同的优化级别下生成的汇编代码。同时也支持rust，haskell等其他语言。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-1497247a96db6ecfe71c6fa7439ba98b.png" alt="compiler explorer"></p><ul><li>在线对比两段代码的速度：<a href="https://quick-bench.com/q/eP40RY6zDK-eJFdSSPBINa0apTM" target="_blank" rel="noreferrer">Quick C++ Benchmark</a>. 基于Google的benchmark框架，需要学习google benchmark的语法才能使用。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-f01b7d805a085aee21a919be7b523c33.png" alt="Quick C++ Benchmark"></p><h2 id="结语" tabindex="-1">结语 <a class="header-anchor" href="#结语" aria-hidden="true">#</a></h2><p>各种配置过程已经在虚拟机上测试过了，应当没有问题，也欢迎各位交流讨论。</p><p><strong>最后感谢各位耐心阅读~</strong></p><h3 id="change-logs" tabindex="-1">Change Logs <a class="header-anchor" href="#change-logs" aria-hidden="true">#</a></h3><h4 id="_2022-12-16" tabindex="-1">2022/12/16 <a class="header-anchor" href="#_2022-12-16" aria-hidden="true">#</a></h4><ul><li>补充关于MSYS2国内镜像相关内容</li><li>添加两本CMake学习用书，CMake的文档太差了</li><li>更新了子环境wrapper</li></ul><h4 id="_2022-06-28" tabindex="-1">2022/06/28 <a class="header-anchor" href="#_2022-06-28" aria-hidden="true">#</a></h4><ul><li>添加ChangeLog，替换了部分老旧链接</li><li>修正一些错误，重写了#5</li><li>考虑到win7/8即将结束支持，子环境选择上改为推荐UCRT64</li><li>由于我已经迁移到win11，所以增加了一些win11相关内容</li></ul><h4 id="_2021-11-19" tabindex="-1">2021/11/19 <a class="header-anchor" href="#_2021-11-19" aria-hidden="true">#</a></h4><ul><li>重组和精简部分内容</li><li>更新MinGW/MSYS2历史相关</li><li>添加命令行使用gcc相关</li></ul>`,200),c=[l];function r(t,p,i,d,h,g){return a(),s("div",null,c)}const _=e(o,[["render",r]]);export{u as __pageData,_ as default};
